# -*- coding: utf-8 -*-
"""taylor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nk2kf3AyhV8jjVjAcQj5B5Luwf-EIrsT
"""

#Import libraries
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
x = sp.Symbol('x')


def taylor(func, start, end, degree, fixed_c):
    #Initialize list and set constant c
    approx = []
    c = fixed_c

    #Iterate over 100 points between start and finish value
    for n in np.linspace(start,end,100):
        #Initialize variables per iteration
        value = 0
        f = func

        #Perform the Taylor summation of i terms
        for i in range(degree):
            value += ((f.subs(x,c)) * (((n - c) ** i))) / sp.factorial(i)

            #Take derivative for next iteration
            f = sp.diff(f,x)

        #Add summation value to the list
        approx.append(value)

    #Convert list to an array
    approx = np.array(approx)
    return approx

#Run Taylor Approximation on the function
taylor_approx = taylor((x * (sp.sin(x) ** 2)) + sp.cos(x), -10, 10, 99, 0)

#Find the actual values for the function
x = np.linspace(-10,10,100)
actual = (x * (np.sin(x) ** 2)) + np.cos(x)

#Plot the Taylor Approximation and the actual function
plt.plot(x, taylor_approx, 'o',color = 'red', label = 'Taylor Approximation')
plt.plot(x, actual, color = 'blue', label = 'Actual')
plt.legend()
plt.xlabel('x')
plt.ylabel('xsin\u00b2(x) + cos(x)')
plt.savefig('taylor.png')
plt.show()

#Import libraries
import numpy as np
import sympy as sp
import time
import pandas as pd
x = sp.Symbol('x')

def taylor_factorial(func, start, end, degree, fixed_c, initial_degree, final_degree, degree_step):
    #Initialize variables and lists
    c = fixed_c
    Cutoff_Value = []
    Difference = []
    Time = []
    i = initial_degree

    #Iterate according to the inital degree, final degree,
    #and degreee step values
    while i <= final_degree:
        #Initialize lists
        diff = []
        approx = []
        actual = []

        #Start timer for approximation
        start_time = time.perf_counter()
        for _ in range(1000000):
            pass

        #Calculate approximate value for 100 x-values between -10 and 10
        #And add to a list
        for n in np.linspace(start,end,100):
            value = 0
            f = func
            for j in range(i):
                value += ((f.subs(x,c)) * (((n - c) ** j))) / sp.factorial(j)
                f = sp.diff(f,x)
            approx.append(value)

        #Make the list an array
        approx = np.array(approx)

        #End timer after approximation is made and calculate elapsed time
        end_time = time.perf_counter()
        elapsed_time = end_time - start_time

        #Calculate the actual values of the function and make it an array
        for n in np.linspace(start,end,100):
            actual.append((n * (np.sin(n) ** 2)) + np.cos(n))
        actual = np.array(actual)

        #Take the sum of the absolute value of the differnce between the
        #approximate and the actual values
        diff = np.abs(approx - actual)
        diff = np.sum(diff)

        #Add the iteration, sum of differences, and elasped time to a list
        Cutoff_Value.append(i)
        Difference.append(diff)
        Time.append(elapsed_time)

        #Iterate to the next step degree
        i += degree_step

    #Make the data a panda dataframe and save to a .csv file
    data = {'Cutoff value': Cutoff_Value, 'Difference': Difference, 'Time': Time}
    df = pd.DataFrame(data)
    df.to_csv("taylor_values.csv", index = False)
    return print('Dataframe exported to taylor_values.csv')

taylor_factorial((x * (sp.sin(x) ** 2)) + sp.cos(x), -10, 10, 99, 0, 50, 100, 10)